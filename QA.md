# 一些基本原理解释和可能被问到的问题解答
## Q: 什么是指针规划算法？
A: 指针规划算法算是我自己造的一个词，用来指代一类函数，这些函数输入一个谱面，输出一个对应的触控事件序列。
这里的指针，其实是对触发屏幕触控事件的一类物体的统称，例如手指，或是触控笔，甚至包括虚拟指针。

## Q: 为什么需要指针规划算法？
A: 对于安卓设备，每一个触控事件都需要指定一个唯一的指针ID(pointer id)，用于标识不同的手指的操作。而且，同一时刻，系统仅允许屏幕上最多存在10个指针。

所以，这些规划算法在生成触控事件序列的同时，还需要负责为这些触控事件填上合适的指针id。

看起来，一种简单可行的方法是，给chart中的每个note分配一个唯一的id，因为pointer id是一个uint64_t，最多支持18446744073709551616个不同的指针，而phigros的谱面物量远远小于这个数。所以只需要考虑如何应对每个note即可。

但这只是看起来可行，因为phigros中存在两种note（实际上绝大多数音游都有，不过这里我们只讨论Phigros）：drag和flick（即黄键和红键）。

这两种note的特殊之处在于，它们的判定都不关注UP（抬起：将一个指针从屏幕上移除）和DOWN（落下：将一个指针放到屏幕上）事件，虽然drag也可以用点击来触发，不过实际上判定的还是触点的位置，也就是说，在判定区只要存在一个指针即可。

所以，正常来讲，遇到drag时，phisap应该发送一个MOVE（移动：改变指针的位置）事件，将一个指针移动过去（当然如果判定区里已经有了那么就不需要发送事件了）。遇到flick时，phisap应该发送一系列MOVE事件，将一个指针在判定区里来回摩擦。

但这又会遇到一个问题，就是如果一个指针现在不在屏幕上（也就是说没有产生过DOWN事件，或是DOWN事件被UP事件抵消了），那么一切关于它的MOVE事件都将被系统忽略。也就是我们不能凭空生成一个指针ID，然后MOVE它。我们只能MOVE屏幕上现存的指针。

那么能否将drag看作tap，将flick看作移动位置的hold呢？这样就不用考虑屏幕上存在的指针了。

答案是否定的，不过事实上，phisap的初期确实是采用的这种方式，对于这两种note，先在开始时加一个DOWN事件，等判定成功后再加一个UP事件。但实际上，这会导致其他note的判定问题，例如tap（蓝键）和hold（长蓝条）的过早触发。

考虑这样一种情况：两个note的下落方向垂直，一个是tap，一个是drag，drag的击打位置包含在tap的判定区内，且drag应该先于tap触发。但如果将drag看作tap后，击打drag将会导致tap也会同时被触发，这样就会使tap被判定为Good或者Bad。flick同理。

除此之外，phigros的一些谱面实际上会有同一时刻触发大于10个note的情况，例如Mountain Eater的IN，结尾处的8个hold加上一些drag。如果给每个note分配一个指针，那么同样会被多点触控机制限制住。所以，就需要一个算法来“联动”这些note，合并它们的判定条件，进而减少指针的使用，实际上，例子中结尾那一段只需要两个指针即可完成任务。这些就是指针规划算法需要完成的工作。

# Q: "algo1"和"algo2"是什么？二者的区别是？
A: 首先，"algo"是算法(algorithm)的简写。所以，"algo1"就是"算法1"，"algo2"就是"算法2"。二者都是指针规划算法。当然，重构UI后可能就没有这种说法了。


